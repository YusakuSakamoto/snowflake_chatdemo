
schema_id:: SCH_20251226180633

```dataview
TABLE comment, physical
FROM "master/tables"
WHERE schema_id = this.schema_id
SORT schema_id, physical
```

## DB_DESIGN スキーマ 設計意図・全体設計

---

## 1. このスキーマの位置づけ

`DB_DESIGN` スキーマは、業務データを格納するためのスキーマではない。  
本スキーマの役割は次の一点に集約される。

データベース設計そのものを「管理対象データ」として扱い、  
設計 → 合意 → レビュー → 改善のサイクルを回すための基盤を提供すること

つまり `DB_DESIGN` は、

- 業務DBを「どう設計したか」
- なぜその設計判断をしたか
- 実データ・運用結果と設計が乖離していないか

をメタレベルで管理するためのスキーマである。

---

## 2. 設計思想の中核

### 2.1 Obsidian Vault を正本とする理由

本基盤では、Obsidian Vault（Markdown）を DB 設計の正本とする。

理由は以下のとおり：

- DB 上の DDL は「結果物」であり、設計判断の文脈を保持できない
- Markdown は
  - Git 管理できる
  - 差分レビューが可能
  - 人と機械の両方が読める
- Cortex Agent / Search と組み合わせることで
  - 設計レビュー
  - 設計照会（Q&A）
  - 改善提案
  を自動化可能

したがって、

- Snowflake 上の `DB_DESIGN` テーブル群は設計メタ情報の反映・運用用
- 設計の正しさ・合意の根拠は常に Vault 側にある

という前提を崩さない。

---

### 2.2 「定義」と「設計意図」を分離する

本基盤では、情報を明確に分離する。

| 区分 | 役割 |
|---|---|
| master/ | 機械可読な定義の正本（DDL生成対象） |
| design/ | 人が読む設計意図・判断・前提 |
| reviews/ | レビュー結果・改善提案・履歴 |
| views/ | Dataview による一覧・横断チェック |

この分離により、

- 定義変更 ≠ 設計意図変更
- レビュー履歴 ≠ 現在の定義

が混線しない。

---

## 3. ID設計（不変性の思想）

### 3.1 なぜ ID を不変にするのか

- schema / table / column は名前が変わる
- しかし「同一概念かどうか」は設計上重要

そのため本基盤では、

- `schema_id`
- `table_id`
- `column_id`

を論理的な不変IDとして採用する。

ファイル名・物理名・論理名が変わっても、  
ID が同じなら同一設計要素として追跡できる。

---

### 3.2 ID を使うことによる効果

- Dataview による正確な関連付け
- Cortex Agent による安定した根拠参照
- 名前変更時のレビュー・影響分析が容易

---

## 4. DB_DESIGN スキーマの役割

### 4.1 何を格納するか

`DB_DESIGN` スキーマには以下を格納する：

- プロファイル実行履歴（PROFILE_RUNS）
- プロファイル結果（PROFILE_RESULTS）
- 設計レビュー・計測結果の運用用テーブル
- Agent / 分析処理の実行管理用メタ情報

業務データは一切置かない。

---

### 4.2 なぜ Snowflake 側にも持つのか

理由は「自動化」と「運用性」。

- Cortex Search / Agent は Snowflake 上で動く
- プロファイル結果を
  - 集計
  - 比較
  - 最新化
  するには DB が必要
- ただし Snowflake は正本ではない

必ず以下の流れを守る：

Snowflake → md に変換 → Vault に保存 → Vault が正

---

## 5. レビュー設計の思想

### 5.1 レビューは「静的」に行う

Cortex Agent によるレビューは：

- DB を直接参照しない
- Vault（md）だけを見る
- 実データ結果も md として保存されたもののみを根拠にする

これにより：

- レビューの再現性が保証される
- 「その時のDB状態」に依存しない
- Git 上でレビュー結果を追跡できる

---

### 5.2 Evidence を厳格に扱う理由

レビューでは必ず：

- 実在する md ファイルパス
- 具体的な抜粋

を Evidence として提示する。

これは、

- 「どこにそう書いてあるか」を曖昧にしない
- 設計議論を感覚論にしない
- 後から第三者が検証できる

ための 強制ルールである。

---

## 6. design 配下の構造意図

### 6.1 スキーマ設計書（必須）

`design/design.<SCHEMA>.md`

- スキーマ全体の思想
- 命名・制約ポリシー
- 「DDLで縛らない理由」などの判断

Agent は必ず読む前提で設計されている。

---

### 6.2 テーブル設計書（必須）

`design/<SCHEMA>/design.<TABLE>.md`

- テーブル固有の設計判断
- nullable / default / domain の理由
- PK / FK の選択理由
- 運用時の前提条件

存在しない場合は レビューで明示的に指摘される。

---

## 7. レビュー履歴（reviews/）の位置づけ

`reviews/` は「設計の過去」を残す場所。

- 人手レビュー
- Cortex Agent レビュー
- プロファイル結果に基づく指摘

を 時系列で保存する。

重要なのは：

- reviews は master を直接変更しない
- 改善は「差分案」として提示する

---

## 8. この基盤が目指す最終状態

この仕組みが目指すのは：

- DB 設計が
  - 属人化せず
  - 記憶に頼らず
  - 再現可能で
  - 改善し続けられる
- 「なぜそうなっているか」が必ず Vault に残る
- Agent が
  - 設計を理解し
  - 根拠付きで指摘し
  - 改善サイクルを回す

という状態である。

`DB_DESIGN` はそのための 設計基盤そのものであり、  
単なるメタデータ置き場ではない。

---

## 9. 明示的な非対象

以下は本スキーマ・本 Vault の責務外とする。

- 本番データの保存
- DDL の自動適用
- マイグレーション管理
- データ操作（DML）

これらは別の仕組みで管理し、  
設計基盤を汚染しない。

---

## 10. 最後に

この設計は、

- Obsidian
- Snowflake
- Cortex Search / Agent
- Git

を 無理なく接続するための最小構成である。

重要なのはツールではなく、

設計を「成果物」ではなく「運用・改善され続ける資産」として扱うこと

DB_DESIGN はその思想を実装したスキーマである。
