
schema_id:: SCH_20251226180633

```dataview
TABLE comment, physical
FROM "master/tables"
WHERE schema_id = this.schema_id
SORT schema_id, physical
```

## [[design.DB_DESIGN]] スキーマ 設計意図・全体設計

---

## 1. このスキーマの位置づけ

[[design.DB_DESIGN]] スキーマは、業務データを格納するためのスキーマではない。  
本スキーマの役割は次の一点に集約される。

データベース設計そのものを「管理対象データ」として扱い、  
設計 → 合意 → レビュー → 改善のサイクルを回すための基盤を提供すること

つまり [[design.DB_DESIGN]] は、

- 業務DBを「どう設計したか」
- なぜその設計判断をしたか
- 実データ・運用結果と設計が乖離していないか

をメタレベルで管理するためのスキーマである。

---

## 2. 設計思想の中核

### 2.1 Obsidian Vault を正本とする理由

本基盤では、Obsidian Vault（Markdown）を DB 設計の正本とする。

理由は以下のとおり：

- DB 上の DDL は「結果物」であり、設計判断の文脈を保持できない
- Markdown は
  - Git 管理できる
  - 差分レビューが可能
  - 人と機械の両方が読める
- Cortex Agent / Search と組み合わせることで
  - 設計レビュー
  - 設計照会（Q&A）
  - 改善提案
  を自動化可能

したがって、

- Snowflake 上の [[design.DB_DESIGN]] テーブル群は設計メタ情報の反映・運用用
- 設計の正しさ・合意の根拠は常に Vault 側にある

という前提を崩さない。

---

### 2.2 「定義」と「設計意図」を分離する

本基盤では、情報を明確に分離する。

| 区分 | 役割 |
|---|---|
| master/ | 機械可読な定義の正本（DDL生成対象） |
| design/ | 人が読む設計意図・判断・前提 |
| reviews/ | レビュー結果・改善提案・履歴 |
| views/ | Dataview による一覧・横断チェック |

この分離により、

- 定義変更 ≠ 設計意図変更
- レビュー履歴 ≠ 現在の定義

が混線しない。

---

## 3. ID設計（不変性の思想）

### 3.1 なぜ ID を不変にするのか

- schema / table / column は名前が変わる
- しかし「同一概念かどうか」は設計上重要

そのため本基盤では、

- schema_id
- table_id
- column_id

を論理的な不変IDとして採用する。

ファイル名・物理名・論理名が変わっても、  
ID が同じなら同一設計要素として追跡できる。

---

### 3.2 ID を使うことによる効果

- Dataview による正確な関連付け
- Cortex Agent による安定した根拠参照
- 名前変更時のレビュー・影響分析が容易

---

## 4. [[design.DB_DESIGN]] スキーマの役割

### 4.1 何を格納するか

[[design.DB_DESIGN]] スキーマには以下を格納する：

- プロファイル実行履歴（[[design.PROFILE_RUNS]]）
- プロファイル結果（[[design.PROFILE_RESULTS]]）
- 設計レビュー・計測結果の運用用テーブル
- Agent / 分析処理の実行管理用メタ情報

業務データは一切置かない。

---

### 4.2 なぜ Snowflake 側にも持つのか

理由は「自動化」と「運用性」。

- Cortex Search / Agent は Snowflake 上で動く
- プロファイル結果を
  - 集計
  - 比較
  - 最新化
  するには DB が必要
- ただし Snowflake は正本ではない

必ず以下の流れを守る：

Snowflake → md に変換 → Vault に保存 → Vault が正

---

## 5. レビュー設計の思想

### 5.1 レビューは「静的」に行う

Cortex Agent によるレビューは：

- DB を直接参照しない
- Vault（md）だけを見る
- 実データ結果も md として保存されたもののみを根拠にする

これにより：

- レビューの再現性が保証される
- 「その時のDB状態」に依存しない
- Git 上でレビュー結果を追跡できる

---

### 5.2 Evidence を厳格に扱う理由

レビューでは必ず：

- 実在する md ファイルパス
- 具体的な抜粋

を Evidence として提示する。

これは、

- 「どこにそう書いてあるか」を曖昧にしない
- 設計議論を感覚論にしない
- 後から第三者が検証できる

ための 強制ルールである。

---

## 6. design 配下の構造意図

### 6.1 スキーマ設計書（必須）

`design/design.<SCHEMA>.md`

- スキーマ全体の思想
- 命名・制約ポリシー
- 「DDLで縛らない理由」などの判断

Agent は必ず読む前提で設計されている。

---

### 6.2 テーブル設計書（必須）

`design/<SCHEMA>/design.<TABLE>.md`

- テーブル固有の設計判断
- nullable / default / domain の理由
- PK / FK の選択理由
- 運用時の前提条件

存在しない場合は レビューで明示的に指摘される。

---

## 7. レビュー履歴（reviews/）の位置づけ

`reviews/` は「設計の過去」を残す場所。

- 人手レビュー
- Cortex Agent レビュー
- プロファイル結果に基づく指摘

を 時系列で保存する。

重要なのは：

- reviews は master を直接変更しない
- 改善は「差分案」として提示する

---

## 8. この基盤が目指す最終状態

この仕組みが目指すのは：

- DB 設計が
  - 属人化せず
  - 記憶に頼らず
  - 再現可能で
  - 改善し続けられる
- 「なぜそうなっているか」が必ず Vault に残る
- Agent が
  - 設計を理解し
  - 根拠付きで指摘し
  - 改善サイクルを回す

という状態である。

[[design.DB_DESIGN]] はそのための 設計基盤そのものであり、  
単なるメタデータ置き場ではない。

---

## 9. 明示的な非対象

以下は本スキーマ・本 Vault の責務外とする。

- 本番データの保存
- DDL の自動適用
- マイグレーション管理
- データ操作（DML）

これらは別の仕組みで管理し、  
設計基盤を汚染しない。

---

## 10. 最後に

この設計は、

- Obsidian
- Snowflake
- Cortex Search / Agent
- Git

を 無理なく接続するための最小構成である。

重要なのはツールではなく、

設計を「成果物」ではなく「運用・改善され続ける資産」として扱うこと

[[design.DB_DESIGN]] はその思想を実装したスキーマである。


---

# 付録：Snowflake 設計レビュー用 仕様ルール（抜粋）

この付録は設計レビューの根拠（Evidence）として用いる。レビュー時は本付録の記述を事実として扱い、迷った場合は本付録に従う。

## 1. 制約（Constraints）
- CHECK制約:
  - SnowflakeではDDLの制約としてCHECKは未サポート（CREATE/ALTERでCHECKは使わない）。
  - 値域/形式制約は「検証クエリ」「ETL/ELT時のバリデーション」「内部テーブル化時の運用ルール」で担保する。

- PRIMARY KEY / UNIQUE / FOREIGN KEY:
  - 宣言できても、原則としてDBが強制（enforce）しない前提で設計する。
  - したがって、これらは「メタデータ（意味付け/ドキュメント）」として扱い、品質担保は運用で行う。

- NOT NULL:
  - NOT NULLは「設計ルール」として明確化し、データ生成元・取り込み時点でNULL混入を防ぐ。
  - 外部テーブルでは、NULL混入防止は主に生成元・ファイル品質・検証クエリで担保する。

## 2. 外部テーブル（EXTERNAL TABLE）
- EXTERNAL TABLEは外部ステージ上のファイルを参照するための仕組みであり、内部テーブルのような物理最適化は前提にしない。
- 外部テーブルでの最適化の主戦場:
  - パス設計（例: YEAR=.../MONTH=... など）
  - PARTITION BY の設計
  - クエリ側のWHERE句がパーティション列に一致していること（プルーニング前提）

- クラスタリング（CLUSTER BY / 自動再クラスタリング）:
  - 外部テーブルでは物理再配置の対象にならない前提とし、クラスタリングキーは外部テーブル最適化策として扱わない。
  - 高頻度クエリ・重い集計がある場合は、内部テーブル（取り込み先）でクラスタリングや集約を検討する。

## 3. 品質担保の原則（外部テーブル前提）
- 一意性（PK相当）:
  - 外部テーブルでは制約強制に頼らず、重複検知クエリと下流の排除（dedupe）手順を持つ。
- 値域・形式:
  - CHECKは使えないため、検証クエリ／異常値検知／アラートで担保する。
- 運用:
  - 監視項目（例: refresh失敗、遅延、ファイル数急増、スキャン量増加）と対応手順を設計書に明記する。

## 4. レビュー判定の補助ルール（本付録の使い方）
- 本付録のルールに反する指摘は成立させない（例: 「CHECK制約を追加すべき」は提案として不適切）。
- 「外部テーブルで制約を強制すべき」という表現は避ける。
  - 代替として「運用検証クエリ」「取り込み時バリデーション」「内部テーブル化」を提案する。
